<!DOCTYPE html>
<html>
  <head>
    <title>Blackbox Testing</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

#<center>**What is Black box testing?**</center>
<br>
##<u>Definition:</u>
**Black box testing is a method of software testing that examines the functionality of an application without peering into its internal 
structures or workings. Knowledge of the internal logic of the system being tested is not required.**
<br><br>
The tester has a set of input values and a set of expected output values and is unaware of how the inputs are transformed into those outputs. Since the tester is not able to view what happens on the inside, hence the name blackbox.

---

#<center>**Why is it necessary?**</center>

<ul>
	<li>Black box testing helps in verification of the overall functionality of the system.</li><br>

	<li>Black-box testing is most commonly used type of testing in traditional organizations that have testers as a separate department, especially when they are not proficient in coding and have difficulties to understand the code. It provides external perspective of the software under test.</li><br>
	<li>Since the requirements are an important part of this, it helps in identifying any uncertain, incomplete or inconsistent requirements.</li><br>
	<li>Black box testing handles explicit or stated requirements and implied requirements. Eg: Page numbers, dates, headers, footers etc all improve readibility of the document for the customer.</li><br>
</ul>
---

#<center>**Advantages of Black box testing**</center>
<ul>
	<li>The testing team works independently of the design time. This removes all bias while testing the particular product.</li><br>
	<li>In other testing techniques, the tester must require some technical knowledge or some prgogramming language. Since black box testing does not require any knowledge of the interntal logic, a non-technical person could also perform testing.</li><br>
	<li>It helps in identifying cases where requirements are inconsistent or missing or ambigious.</li><br>
	<li>The testing is performed with the end-user's perspective.</li><br>
	<li>Once the functional specifications are complete, the test cases can be desgined immediately.</li><br>
</ul>
---

#<center>**Disdvantages of Black box testing**</center>
<ul>
	<li>The reason for failures is not found.</li><br>
	<li>Not all properties of the software system can be tested efficiently. This may lead to a number of paths not being tested.</li><br>
	<li>Certain segments of the code may be more complex and require more testing. This becomes difficult using black box testing.</li><br>
	<li>Since the testing team works independently some tests which have already been covered, may get repeated.</li><br>
	<li>Without having clear specifications, designing test cases becomes difficult.</li><br>
</ul>

---

#<center>**Techniques**</center>
<ul>
	<b><li><u>Requirement Based Testing:</u></li></b><br>
	<ul>
		<li>The requirements that were gathered during the ‘Requirement Gathering’ phase are documented in the Software Requirement 			    Specification (SRS).</li><br>
		<li>This testing technique deals with validating the SRS i.e., the test cases, conditions and data are all derived from the 			    requirements. </li><br>
		<li>There are 2 types of requirements:<br>
			&nbsp;&nbsp;&nbsp; i) Explicit requirements are those that are explicitly stated in the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.<br>
			&nbsp;&nbsp;&nbsp;ii) Implicit requirements are those that are those that are not &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;specifically mentioned but assumed to be taken care of.</li>
	</ul>		
<br><i>The biggest advantage of requirement based testing is that it helps in finding out whatever defects are present early in the life-cycle. This is much more cost-efficient than detecting them at some later stage in the life-cycle process.<i>

---

<u>Requirement Traceability Matrix :</u><br>
<br>A Requirement Traceability Matrix (RTM) is used to keep track of the various requirements from the beginning keeps on changing as the lifecycle of the product goes on.<br>
<ul>
	<li>Each requirement is given a unique id and is briefly described. This information is collected from the SRS itself.</li><br>
	<li>The requirements in an RTM are assigned a priority. Tests which are assigned a higher priority will get executed than those having a lower priority. Thus the defects that are found, if any, can be fixed earlier as well.</li><br>
	<li>Test conditions specify the different ways of running the test cases.</li><br>
</ul>

As the life-cycle and the testing continues, the cross-reference between the requirements, the tests and the phase are all recorded in the RTM


---
<b>Example :</b><br>
Let us take a lock and key. We do not know how the levers in the lock work, but we only know the set of inputs (the number of keys, specific sequence of using the keys and the direction of turn of each key) and the expected outcome (locking and unlocking).For example, if a key is turned clockwise it should unlock and if turned anticlockwise it should lock.

<center>Requirement Traceability Matrix<center>
![RTM for example](RTM.png)

---

There are different types of relationships between the requirements and test cases:
<ul>
	<li><b>One to one</b> – For each requirement there is a single test is performed</li><br>
	<li><b>One to many</b> – For eachrequirement there are multiple test cases.</li><br>
	<li><b>Many to one</b> – For a set of requirements a single test case is performed.</li><br>
	<li><b>Many to many</b> – For a set requirements,multiple test cases are performed. This occurs in integration and system testing.</li><br>
	<li><b>One to none</b> - The requirement has no test cases. In this case the testing team should make a decsision on how to deal with this requirement.</li><br>
</ul>

Some requirements require testing in multiple phases of the life-cycle. This criteria could also be mentioned in the RTM.

---

<b><u>Advantages of RTM -</u></b><br>
<ul>
	<li>Provides a way to track the status of each requirement throughout the lif-cycle.</li><br>
	<li>Prioritizing the requirement and test cases helps in catching the defects in high-priority areas as soon as possible. Also allows the tester team to create more test cases for the high-priority areas as they are more critical.</li><br>
	<li>It is easy to see if there are redundant test cases that test the same requirement again which can be removed.</li><br>
	<li>It is easy to see how many test cases were passed, how many failed, what were the defects that were present, number of requirements tested etc.</li><br>
</ul>

---

#<center>**Positive and Negative Testing**</center>

<b><u>Positive Testing :</u></b><br>
Positive testing is done to check whether the system does what it is supposed to do when given correct input. It is done to ensure that it matches the specifications and works as expected.<br><br>

<b><u>Negative Testing :</u></b><br>Negative testing is used to cover those areas for which the product is not designed or coded. Certain inputs may not be covered in the specification. When these inputs are encountered, the system should not crash and be able to handle   those scenarios properly. 

---
<b>Example :</b><br>
Let us take a lock and key. We do not know how the levers in the lock work, but we only know the set of inputs (the number of keys, specific sequence of using the keys and the direction of turn of each key) and the expected outcome (locking and	unlocking). For example, if a key is turned clockwise it should unlock and if turned anticlockwise it should lock.<br>
<center>Positive Testing<br>
![Positve Testing](PositiveTesting.png)<br>
Negative Testing<br>
![Negative Testing](NegativeTesting.png)</center><br>
<b>Diasdvantage:</b><br>
The problem with negative testing is the coverage. For positive testing, coverage is 100% if all the requirements that are specifed are tested. But for negative testing, there are no requirements that are specified. Achieving 100% coverage for negative testing is impractical. 
---
#<center>**Boundary Value Analysis**</center>

Boundaries are the limits of the values of the variables. Generally the errors near the boundaries occur due to the following reasons -<br>
<ul>
	<li>During comparisons, programmers get confused as to which operator they should use when making comparisons. Eg: '>=' or '>'</li><br>
	<li>Different ways to implement a loop, each having a separate way to termate the loop could cause some confusion. Eg: While and Do-While.</li><br>
	<li>The requirement specification may be ambigious arounf the boundaries thus making it difficult to implement.</li><br>
</ul>
Boundary Value Analysis is useful to generate test cases when the input data is made up of clearly identifiable boundaries or ranges. 

---

In order to perform boundary value testing:<br>.
<ul>
	<li>There should be some discontinuity in data values which affect the system. These discontinuities are where the boundaries exist.<li><br>
	<li>Identify the limits. The test cases should be developed to test the software system at these values.<li><br>
	<li>Test the boundaries for hardware requirements also. Eg: If min RAM of a software system is 1GB, this particular boundary should also be tested.</li><br>

Boundary value analysis can also apply to white box testing techniques where the boundaries of data structures like arrays, stacks, queues can also be tested. 
---

	</textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>

























<!DOCTYPE html>
<html>
  <head>
    <title>Blackbox Testing</title>
    <meta charset="utf-8">
    <style>
      @import url(https://fonts.googleapis.com/css?family=Yanone+Kaffeesatz);
      @import url(https://fonts.googleapis.com/css?family=Droid+Serif:400,700,400italic);
      @import url(https://fonts.googleapis.com/css?family=Ubuntu+Mono:400,700,400italic);

      body { font-family: 'Droid Serif'; }
      h1, h2, h3 {
        font-family: 'Yanone Kaffeesatz';
        font-weight: normal;
      }
      .remark-code, .remark-inline-code { font-family: 'Ubuntu Mono'; }
    </style>
  </head>
  <body>
    <textarea id="source">

#<center>**What is Black box testing?**</center>
##<u>Definition:</u>
*Black box testing is a method of software testing that examines the functionality of an application without peering into its internal 
structures or workings. Knowledge of the internal logic of the system being tested is not required.*
<br><br>
Blackbox testing is done from the customer's perspective. The tester has a set of input values and a set of expected output values and is unaware of how the inputs are transformed into those outputs. Since the tester is not able to view what happens on the inside, hence the name blackbox.
<br><br>
The main purpose of the Black Box is to check whether the software is working as per expected in requirement document & whether it is meeting the user's expectations or not.

---

#<center>**Why is it necessary?**</center>

<ul>
	<li>Black box testing helps in verification of the overall functionality of the system.</li><br>
	<li>Black-box testing is most commonly used type of testing in traditional organizations that have testers as a separate department, especially when they are not proficient in coding and have difficulties to understand the code. It provides external perspective of the software under test.</li><br>
	<li>Since the requirements are an important part of this, it helps in identifying any uncertain, incomplete or inconsistent requirements.</li><br>
	<li>Black box testing handles explicit or stated requirements and implied requirements. Eg: Page numbers, dates, headers, footers etc all improve readibility of the document for the customer.</li><br>
	<li>Blackbox testing handles both valid and invalid inputs. Testing for invalid inputs is important as the customer could enter an input incorrectly. It is essential that the software is able to handle such inputs.</li>
</ul>
---

#<center>**Advantages of Black box testing**</center>
<ul>
	<li>The testing team works independently of the design time. This removes all bias while testing the particular product.</li><br>
	<li>In other testing techniques, the tester must require some technical knowledge or some programming language. Since black box testing does not require any knowledge of the interntal logic, a non-technical person could also perform testing.</li><br>
	<li>It helps in identifying cases where requirements are inconsistent or missing or ambigious.</li><br>
	<li>The testing is performed with the end-user's perspective.</li><br>
	<li>Once the functional specifications are complete, the test cases can be desgined immediately.</li><br>
</ul>
---

#<center>**Disdvantages of Black box testing**</center>
<ul>
	<li>The reason for failures is not found as the internal logic is not explored.</li><br>
	<li>Not all properties of the software system can be tested efficiently. This may lead to a number of paths not being tested.Especially when it comes to testing for invalid inputs.</li><br>
	<li>Certain segments of the code may be more complex and require more testing. This becomes difficult using black box testing.</li><br>
	<li>Since the testing team works independently some tests which have already been covered, may get repeated.</li><br>
	<li>Without having clear specifications, designing test cases becomes difficult.</li><br>
</ul>

---

#<center>**Blackbox Testing vs Whitebox Testing**</center>

There is no simple answer to the question as to which testing methodology is the better one. Both the testing methodologies focus on different aspects of the software.<br><br> 
Blackbox testing is more concerned about the results produced when fed a certain input. It tests the user's experience with the software<br><br>
Whitebox testing pays attention to the details and inner workings of the software. It focuses on the internal structure and attempts to make sure that the software works as efficiently as possible
<br><br>
Therefore, both these testing methodlogies compliment each other and should be used to ensure that the software is tested as comprehensively as possible.

---

#<center>**Techniques**</center>
<ul>
	<b><li><u>Requirement Based Testing:</u></li></b><br>
	<ul>
		<li>The requirements that were gathered during the ‘Requirement Gathering’ phase are documented in the Software Requirement 			    Specification (SRS).</li><br>
		<li>This testing technique deals with validating the SRS i.e., the test cases, conditions and data are all derived from the 			    requirements. </li><br>
		<li>There are 2 types of requirements:<br>
			&nbsp;&nbsp;&nbsp; i) Explicit requirements are those that are explicitly stated in the &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; document.<br>
			&nbsp;&nbsp;&nbsp;ii) Implicit requirements are those that are not specifically  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mentioned but assumed to be taken care of.</li>
	</ul>		
<br><i>The biggest advantage of requirement based testing is that it helps in finding out whatever defects are present early in the life-cycle. This is much more cost-efficient than detecting them at some later stage in the life-cycle process.<i>

---

<b>Requirement Traceability Matrix :</b><br>
<br>A Requirement Traceability Matrix (RTM) is used to keep track of the various requirements from the beginning and keeps on changing as the lifecycle of the product goes on.<br>
<ul>
	<li>Each requirement is given a unique id and is briefly described. This information is collected from the SRS itself.</li><br>
	<li>The requirements in an RTM are assigned a priority. Tests which are assigned a higher priority will get executed than those having a lower priority.</li><br> 
        <li>This prioritising of test cases, helps in finding out test cases early in the process.</li><br>
	<li>Test conditions specify the different ways of running the test cases.</li><br>
</ul>

---
<b>Example :</b>
Let us take a lock and key. We do not know how the levers in the lock work, but we only know the set of inputs (the number of keys, specific sequence of using the keys and the direction of turn of each key) and the expected outcome (locking and unlocking).For example, if a key is turned clockwise it should unlock and if turned anticlockwise it should lock.

<center>Requirement Traceability Matrix<center>
![RTM for example](RTM.png)

---

There are different types of relationships between the requirements and test cases:
<ul>
	<li><b>One to one</b> – For each requirement there is a single test that is performed</li><br>
	<li><b>One to many</b> – For each requirement there are multiple test cases.</li><br>
	<li><b>Many to one</b> – For a set of requirements there is a single test that is performed.</li><br>
	<li><b>Many to many</b> – For a set of requirements there are multiple tests that are performed. This occurs in integration and system testing.</li><br>!
	<li><b>One to none</b> - The requirement has no test cases. In this case the testing team should make at decsision on how to deal with this requirement.</li><br>
</ul>

Some requirements require testing in multiple phases of the life-cycle. This criteria could also be mentioned in the RTM.

---

<b><u>Advantages of RTM -</u></b><br>
<ul>
	<li>Provides a way to track the status of each requirement throughout the life-cycle.</li><br>
	<li>Prioritizing the requirement and test cases helps in catching the defects in high-priority areas as soon as possible. Also allows the tester team to create more test cases for the high-priority areas as they are more critical.</li><br>
	<li>It is easy to see if there are redundant test cases that test the same requirement again which can be removed.</li><br>
	<li>It is easy to see how many test cases were passed, how many failed, what were the defects that were present, number of requirements tested etc.</li><br>
</ul>

---

#<center>**Positive and Negative Testing**</center>

<b><u>Positive Testing :</u></b><br><br>
Positive testing is done to check whether the system does what it is supposed to do when given correct input. It is done to ensure that the system matches the specifications and works as expected.The tester only tests for a valid set of inputs. If no error is expected, then no error should be displayed. If an error is expected, then an error message should be displayed.<br><br>

<b><u>Negative Testing :</u></b><br><br>
Negative testing is used to cover those areas for which the product is not designed or coded. Certain inputs may not be covered in the specification. When these inputs are encountered, the system should not crash and be able to handle those scenarios properly. The main intention of this testing is to check whether software application does not show error when supposed to and shows an error when not supposed to.

---
<b>Example :</b>Let us take a lock and key. We do not know how the levers in the lock work, but we only know the set of inputs - the number of keys, specific sequence of using the keys and the direction of turn of each key, and the expected outcome - locking and	unlocking. For example, if a key is turned clockwise it should unlock and if turned anticlockwise it should lock.<br>
<center>Positive Testing<br>
![Positve Testing](PositiveTesting.png)<br>
Negative Testing<br>
![Negative Testing](NegativeTesting.png)</center>
The negative testing test cases has covered those areas that the system was not designed for.<br><br>
<b>Diasdvantage:</b>
The problem with negative testing is the coverage. For positive testing, coverage is 100% if all the requirements that are specifed are tested. But for negative testing, there are no requirements that are specified. Achieving 100% coverage for negative testing is impractical. 
---
#<center>**Boundary Value Analysis**</center>

Boundaries are the limits of the values of the variables. Generally the errors near the boundaries occur due to the following reasons -<br>
<ul>
	<li>During comparisons, programmers get confused as to which operator they should use. Eg: '>=' or '>'</li><br>
	<li>Different ways to implement a loop, each having a separate way to termate the loop could cause some confusion. Eg: While and Do-While.</li><br>
	<li>The requirement specification may be ambigious arounf the boundaries thus making it difficult to implement.</li><br>
</ul>
Boundary Value Analysis is useful to generate test cases when the input data is made up of clearly identifiable boundaries or ranges. 

---
<center>Boundary Value Analysis Example<center>
![BVA for example](BVA.png)

---

In order to perform boundary value testing:<br>
<ul>
	<li>There should be some discontinuity in data values which affect the system. These discontinuities are where the boundaries exist.</li><br>
	<li>Identify the limits. The test cases should be developed to test the software system at these values.</li><br>
	<li>Test the boundaries for hardware requirements also. Eg: If min RAM of a software system is 1GB, this particular boundary should also be tested.</li><br>

Boundary value analysis can also apply to white box testing techniques where the boundaries of data structures like arrays, stacks, queues can also be tested. 

---
#<center>**Decision Table**</center>

Decision table lists out all the variables that are involved in the decision making process, the condition of the variables and the actions that need to be taken for each combination of the decision variables. 
<br><br>
The decision variables are columns of the decision tables. The last column lists the actions that are taken.
<br><br>
If the values for the various decisions can be boolean values, it becomes simpler to read and understand. 
<br><br>
"Don't care" conditions are the conditions which do not affect the outcome and are either left empty or marked with a "-". Each row of the table specifies one test case. As expected, if there are more "don't care" conditions, the number of test cases is minimsed. 
---
<b>Steps to form a decision table :</b><br><br>
<ul>
        <li>Identify the decision variables invlolved.</li><br><br>
        <li>Identify the possible values that each decision variable can take.</li><br><br>
        <li>List out the various possible combinations of the decision variables.</li><br><br>
        <li>Identify the scenarios when a value of a variable doesn't affect the decision in any way. Mark these as "don't care".</li><br><br>
        <li>For the various combinations listed out, list out the possible outcome. The end result should be entered in the last column.</li><br><br>
</ul>

---
<center><b>Example :</b><center>![DecisionTableQues](DecisionTableQues.png)
---
<center><b>Decision Table :</b><center>![DecisionTable](DecisionTable.png)
---
#<center>**Equivalence Partitioning**</center>
<br>
It is a testing technique which involves using a small set of representative values that produce as many different outputs as possible.
<br><br>
Each set that generates a single expected output is called a partition. When the software behaves in the same way for a set of values, then that set of values is refered to as an equivalence partition.
<br><br>
From each equivalence partition, a single value is chosen to do the testing. This is because picking multiple values from the same set produces the same result. 
<br><br>
<b>Advantage :</b>Good coverage is attained with just a small number of test cases. If a defect occurs for a particular test value, then that defect will occur for all the other values in that equivalence partition. Thus, it helps in reducing redundancy.

---
<center><b>Example :</b><center>![EquiPartQues](EquiPartQues.png)
<br><br><br>
<center><b>Equivalence Partitions :</b><center>![EquiPart](EquiPart.png)

---
#<center>**Reference**</center>
[1] Software Testing: Principles and Practices - Srinivasan Desikan and Gopalaswamy Ramesh<br>
[2] Wikipedia<br>
[3] http://www.softwaretestingclass.com<br>
[4] http://www.guru99.com<br>
[5] http://www.ofnisystems.com/services/validation/traceability-matrix/<br>

	</textarea>
    <script src="https://gnab.github.io/remark/downloads/remark-latest.min.js">
    </script>
    <script>
      var slideshow = remark.create();
    </script>
  </body>
</html>
























